// A new homebrew mapper produced by Broke Studio. Used for the physical
// release of Super Tilt Bro. Currently in development, but the features
// should be mostly set in stone by this point. Documentation:
// https://github.com/BrokeStudio/rainbow-net/blob/master/NES/mapper-doc.md

// As the hardware is not yet released, this is a THEORETICAL mapper
// implementation. Once we have access to the hardware and can run real
// tests to verify behavior, the implementation will be updated and this
// notice removed. Until then, please be careful relying on this during
// new homebrew development.

use ines::INesCartridge;
use memoryblock::MemoryBlock;
use memoryblock::MemoryType;

use mmc::mapper::*;

use apu::AudioChannelState;
use mmc::vrc6::Vrc6PulseChannel;
use mmc::vrc6::Vrc6SawtoothChannel;

#[derive(Debug,Copy,Clone)]
pub enum PrgRomBankingMode {
    Mode0Bank1x32k,
    Mode1Bank2x16k,
    Mode2Bank1x16k2x8k,
    Mode3Bank4x8k,
    Mode4Bank8x4k
}

#[derive(Debug,Copy,Clone)]
pub enum PrgRamBankingMode {
    Mode0Bank1x8k,
    Mode1Bank2x4k
}

#[derive(Debug,Copy,Clone)]
pub enum ChrBankingMode {
    Mode0Bank1x8k,
    Mode1Bank2x4k,
    Mode2Bank4x2k,
    Mode3Bank8x1k,
    Mode4Bank16x512b
}

#[derive(Debug,Copy,Clone)]
pub enum ChrChipSelect {
    ChrRom,
    ChrRam,
    FpgaRam
}

#[derive(Debug,Copy,Clone)]
pub enum NametableChipSelect {
    CiRam,
    ChrRam,
    FpgaRam,
    ChrRom,
}

#[derive(Copy, Clone, PartialEq)]
pub enum PpuMode {
    Backgrounds,
    Sprites,
    PpuData
}

pub struct Rainbow {
    prg_rom: MemoryBlock,
    prg_ram: MemoryBlock,
    chr_rom: MemoryBlock,
    chr_ram: MemoryBlock,

    prg_rom_mode: PrgRomBankingMode,
    prg_ram_mode: PrgRamBankingMode,
    chr_mode: ChrBankingMode,
    chr_chip: ChrChipSelect,

    prg_bank_at_8000: usize,
    prg_bank_at_9000: usize,
    prg_bank_at_a000: usize,
    prg_bank_at_b000: usize,
    prg_bank_at_c000: usize,
    prg_bank_at_d000: usize,
    prg_bank_at_e000: usize,
    prg_bank_at_f000: usize,

    prg_ram_at_8000: bool,
    prg_ram_at_9000: bool,
    prg_ram_at_a000: bool,
    prg_ram_at_b000: bool,
    prg_ram_at_c000: bool,
    prg_ram_at_d000: bool,
    prg_ram_at_e000: bool,
    prg_ram_at_f000: bool,
    
    prg_bank_at_6000: usize,
    prg_bank_at_7000: usize,

    prg_ram_at_6000: bool,
    prg_ram_at_7000: bool,
    fpga_ram_at_6000: bool,
    fpga_ram_at_7000: bool,

    fpga_bank_at_5000: usize,
    chr_banks: Vec<usize>,
    chr_bank_high_bits: usize,

    window_split: bool,
    extended_sprites: bool,

    mirroring: Mirroring,
    ciram: MemoryBlock,
    fpga_ram: MemoryBlock,

    // Rainbow says it uses VRC6 semantics in its documentation. Until I find
    // a difference in the hardware, I'm just going to present actual VRC6 channels
    // for it to drive, similar to NSF, but with a custom output stage.
    vrc6_pulse1: Vrc6PulseChannel,
    vrc6_pulse2: Vrc6PulseChannel,
    vrc6_sawtooth: Vrc6SawtoothChannel,

    vrc6_exp6: bool,
    vrc6_exp9: bool,
    vrc6_zpcm: bool,

    cpu_irq_counter: u16,
    cpu_irq_latch: u16,
    cpu_irq_enable: bool,
    cpu_irq_auto_repeat: bool,
    cpu_irq_pending: bool,

    nametable_bank_at_2000: usize,
    nametable_bank_at_2400: usize,
    nametable_bank_at_2800: usize,
    nametable_bank_at_2c00: usize,

    nametable_chip_at_2000: NametableChipSelect,
    nametable_chip_at_2400: NametableChipSelect,
    nametable_chip_at_2800: NametableChipSelect,
    nametable_chip_at_2c00: NametableChipSelect,

    extended_attributes_2000: bool,
    extended_attributes_2400: bool,
    extended_attributes_2800: bool,
    extended_attributes_2c00: bool,

    extended_backgrounds_2000: bool,
    extended_backgrounds_2400: bool,
    extended_backgrounds_2800: bool,
    extended_backgrounds_2c00: bool,

    exram_bank_2000: usize,
    exram_bank_2400: usize,
    exram_bank_2800: usize,
    exram_bank_2c00: usize,

    // snooping PPU behavior and state
    scanline_irq_pending: bool,
    scanline_irq_enabled: bool,
    scanline_irq_compare: u8,
    scanline_irq_offset: u8,
    scanline_jitter_counter: u8,

    ppu_read_mode: PpuMode,
    in_frame: bool,
    in_hblank: bool,
    current_scanline: u8,
    consecutive_nametable_count: u8,
    cpu_cycles_since_last_ppu_read: u8,
    ppu_fetches_this_scanline: u8,
    last_ppu_fetch: u16,
    last_bg_tile_fetch: u16,


    // TODO: extended nametable modes, including: fill, attribute, background
    // TODO: window split nametable and configuration
}

impl Rainbow {
    pub fn from_ines(ines: INesCartridge) -> Result<Rainbow, String> {
        // PRG ROM should always be present. We assume it is self-flashable
        // for emulation purposes.
        let prg_rom_block = ines.prg_rom_block();
        // PRG RAM follows the usual conventions: it may be battery
        // backed or not, but we don't support a mix of the two
        let prg_ram_block = ines.prg_ram_block()?;

        // CHR may be present in ROM, RAM, or a mix of the two, but will
        // never be battery backed. This is highly unusual among mappers,
        // so we'll parse the fields somewhat manually here. We assume
        // that CHR ROM is self-flashable.
        let chr_rom_block = if ines.chr.len() > 0 {
            MemoryBlock::new(&ines.chr, MemoryType::Rom)
        } else {
            MemoryBlock::new(&Vec::new(), MemoryType::Rom)
        };

        if ines.header.chr_ram_size() > 0 && ines.header.chr_sram_size() > 0 {
            return Err(format!("Rainbow: Unsupported mixed CHR types for mapper number {}", ines.header.mapper_number()));
        }

        let chr_ram_block = if ines.header.chr_ram_size() > 0 {
            let mut chr_ram: Vec<u8> = Vec::new();
            chr_ram.resize(ines.header.chr_ram_size(), 0);
            MemoryBlock::new(&chr_ram, MemoryType::Ram)
        } else if ines.header.chr_sram_size() > 0 {
            println!("Rainbow: Unsupported non-volatile CHR RAM! Loading anyway, will treat like volatile CHR RAM instead. Game saving may not work!");
            let mut chr_sram: Vec<u8> = Vec::new();
            chr_sram.resize(ines.header.chr_sram_size(), 0);
            MemoryBlock::new(&chr_sram, MemoryType::Ram)
        } else {
            MemoryBlock::new(&Vec::new(), MemoryType::Rom)
        };

        let mut fpga_ram: Vec<u8> = Vec::new();
        fpga_ram.resize(0x2000, 0);
        // The first 4k of FPGA have fixed, known contents from the bootrom before the
        // hosted program takes control. We don't emulate this bootrom, but for compatibility
        // we need to initialize the FPGA RAM with the written data. This mostly affects
        // the test ROMs, but in theory games could use the font that is loaded here.
        for i in 0 .. 4096 {
            fpga_ram[i] = BOOTROM_FPGA[i];
        }
        let fpga_ram_block = MemoryBlock::new(&fpga_ram, MemoryType::Ram);

        // for simplicity, we'll also handle ciram as a banked block
        let mut ciram: Vec<u8> = Vec::new();
        ciram.resize(0x800, 0);
        let ciram_block = MemoryBlock::new(&ciram, MemoryType::Ram);

        let mut rainbow = Rainbow {
            prg_rom: prg_rom_block.clone(),
            prg_ram: prg_ram_block.clone(),
            chr_rom: chr_rom_block.clone(),
            chr_ram: chr_ram_block.clone(),

            prg_rom_mode: PrgRomBankingMode::Mode0Bank1x32k,
            prg_ram_mode: PrgRamBankingMode::Mode0Bank1x8k,
            chr_mode: ChrBankingMode::Mode0Bank1x8k,
            chr_chip: ChrChipSelect::ChrRom,

            prg_bank_at_8000: 0,
            prg_bank_at_9000: 0,
            prg_bank_at_a000: 0,
            prg_bank_at_b000: 0,
            prg_bank_at_c000: 0,
            prg_bank_at_d000: 0,
            prg_bank_at_e000: 0,
            prg_bank_at_f000: 0,

            prg_ram_at_8000: false,
            prg_ram_at_9000: false,
            prg_ram_at_a000: false,
            prg_ram_at_b000: false,
            prg_ram_at_c000: false,
            prg_ram_at_d000: false,
            prg_ram_at_e000: false,
            prg_ram_at_f000: false,
            
            prg_bank_at_6000: 0,
            prg_bank_at_7000: 0,

            prg_ram_at_6000: true,
            prg_ram_at_7000: true,
            fpga_ram_at_6000: false,
            fpga_ram_at_7000: false,

            fpga_bank_at_5000: 0,
            chr_banks: vec![0usize; 16],
            chr_bank_high_bits: 0,

            window_split: false,
            extended_sprites: false,

            mirroring: ines.header.mirroring(),
            ciram: ciram_block.clone(),
            fpga_ram: fpga_ram_block.clone(),

            vrc6_pulse1: Vrc6PulseChannel::new("Pulse 1"),
            vrc6_pulse2: Vrc6PulseChannel::new("Pulse 2"),
            vrc6_sawtooth: Vrc6SawtoothChannel::new(),

            vrc6_exp6: true,
            vrc6_exp9: true,
            vrc6_zpcm: false,

            cpu_irq_counter: 0xFFFF,
            cpu_irq_latch: 0xFFFF,
            cpu_irq_enable: false,
            cpu_irq_auto_repeat: false,
            cpu_irq_pending: false,

            scanline_irq_enabled: false,
            scanline_irq_pending: false,
            scanline_irq_compare: 0xFF,
            scanline_irq_offset: 0x87,
            scanline_jitter_counter: 0,

            ppu_read_mode: PpuMode::PpuData,
            in_frame: false,
            in_hblank: false,
            current_scanline: 0,
            consecutive_nametable_count: 0,
            cpu_cycles_since_last_ppu_read: 0,
            ppu_fetches_this_scanline: 0,
            last_ppu_fetch: 0,
            last_bg_tile_fetch: 0,

            // 
            nametable_bank_at_2000: 0,
            nametable_bank_at_2400: 0,
            nametable_bank_at_2800: 1,
            nametable_bank_at_2c00: 1,

            nametable_chip_at_2000: NametableChipSelect::CiRam,
            nametable_chip_at_2400: NametableChipSelect::CiRam,
            nametable_chip_at_2800: NametableChipSelect::CiRam,
            nametable_chip_at_2c00: NametableChipSelect::CiRam,

            extended_attributes_2000: false,
            extended_attributes_2400: false,
            extended_attributes_2800: false,
            extended_attributes_2c00: false,

            extended_backgrounds_2000: false,
            extended_backgrounds_2400: false,
            extended_backgrounds_2800: false,
            extended_backgrounds_2c00: false,

            exram_bank_2000: 0,
            exram_bank_2400: 0,
            exram_bank_2800: 0,
            exram_bank_2c00: 0,
        };
        // enable all VRC6 channels, disable frequency scaling (which Rainbow doesn't support)
        rainbow.vrc6_pulse1.write_register(3, 0x00);
        rainbow.vrc6_pulse2.write_register(3, 0x00);
        rainbow.vrc6_sawtooth.write_register(3, 0x00);
        return Ok(rainbow);
    }

    // helper functions to deal with being able to selectively map ROM/RAM/FPGA into several regions
    fn read_banked_memory(&self, is_fpga: bool, is_ram: bool, bank_number: usize, blocksize: usize, address: usize) -> Option<u8> {
        if is_fpga {
            self.fpga_ram.banked_read(blocksize, bank_number, address)
        } else if is_ram {
            self.prg_ram.banked_read(blocksize, bank_number, address)
        } else {
            self.prg_rom.banked_read(blocksize, bank_number, address)
        }
    }

    fn write_banked_memory(&mut self, is_fpga: bool, is_ram: bool, bank_number: usize, blocksize: usize, address: usize, data: u8) {
        // Note: ignoring flash memory rewriting for now, that'll probably be handled elsewhere
        if is_fpga {
            self.fpga_ram.banked_write(blocksize, bank_number, address, data)
        } else if is_ram {
            self.prg_ram.banked_write(blocksize, bank_number, address, data)
        }
    }

    fn read_fpga_area(&self, address: usize) -> Option<u8> {
        self.read_banked_memory(true, false, self.fpga_bank_at_5000, 0x1000, address)
    }

    fn write_fpga_area(&mut self, address: usize, data: u8) {
        self.write_banked_memory(true, false, self.fpga_bank_at_5000, 0x1000, address, data)
    }

    fn read_prg_ram_area(&self, address: usize) -> Option<u8> {
        match self.prg_ram_mode {
            PrgRamBankingMode::Mode0Bank1x8k => self.read_banked_memory(self.fpga_ram_at_6000, self.prg_ram_at_6000, self.prg_bank_at_6000, 0x2000, address),
            PrgRamBankingMode::Mode1Bank2x4k => {
                match address {
                    0x6000 ..= 0x6FFF => self.read_banked_memory(self.fpga_ram_at_6000, self.prg_ram_at_6000, self.prg_bank_at_6000, 0x1000, address),
                    0x7000 ..= 0x7FFF => self.read_banked_memory(self.fpga_ram_at_7000, self.prg_ram_at_7000, self.prg_bank_at_7000, 0x1000, address),
                    _ => {None}
                }
            }
        }
    }

    fn write_prg_ram_area(&mut self, address: usize, data: u8) {
        match self.prg_ram_mode {
            PrgRamBankingMode::Mode0Bank1x8k => self.write_banked_memory(self.fpga_ram_at_6000, self.prg_ram_at_6000, self.prg_bank_at_6000, 0x2000, address, data),
            PrgRamBankingMode::Mode1Bank2x4k => {
                match address {
                    0x6000 ..= 0x6FFF => self.write_banked_memory(self.fpga_ram_at_6000, self.prg_ram_at_6000, self.prg_bank_at_6000, 0x1000, address, data),
                    0x7000 ..= 0x7FFF => self.write_banked_memory(self.fpga_ram_at_7000, self.prg_ram_at_7000, self.prg_bank_at_7000, 0x1000, address, data),
                    _ => {}
                }
            }
        }
    }

    fn read_prg_rom_area(&self, address: usize) -> Option<u8> {
        match self.prg_rom_mode {
            PrgRomBankingMode::Mode0Bank1x32k => self.read_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x8000, address),
            PrgRomBankingMode::Mode1Bank2x16k => {
                match address {
                    0x8000 ..= 0xBFFF => self.read_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x4000, address),
                    0xC000 ..= 0xFFFF => self.read_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x4000, address),
                    _ => {None}
                }
            },
            PrgRomBankingMode::Mode2Bank1x16k2x8k => {
                match address {
                    0x8000 ..= 0xBFFF => self.read_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x4000, address),
                    0xC000 ..= 0xDFFF => self.read_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x2000, address),
                    0xE000 ..= 0xFFFF => self.read_banked_memory(false, self.prg_ram_at_e000, self.prg_bank_at_e000, 0x2000, address),
                    _ => {None}
                }
            },
            PrgRomBankingMode::Mode3Bank4x8k => {
                match address {
                    0x8000 ..= 0x9FFF => self.read_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x2000, address),
                    0xA000 ..= 0xBFFF => self.read_banked_memory(false, self.prg_ram_at_a000, self.prg_bank_at_a000, 0x2000, address),
                    0xC000 ..= 0xDFFF => self.read_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x2000, address),
                    0xE000 ..= 0xFFFF => self.read_banked_memory(false, self.prg_ram_at_e000, self.prg_bank_at_e000, 0x2000, address),
                    _ => {None}
                }
            },
            PrgRomBankingMode::Mode4Bank8x4k => {
                match address {
                    0x8000 ..= 0x8FFF => self.read_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x1000, address),
                    0x9000 ..= 0x9FFF => self.read_banked_memory(false, self.prg_ram_at_9000, self.prg_bank_at_9000, 0x1000, address),
                    0xA000 ..= 0xAFFF => self.read_banked_memory(false, self.prg_ram_at_a000, self.prg_bank_at_a000, 0x1000, address),
                    0xB000 ..= 0xBFFF => self.read_banked_memory(false, self.prg_ram_at_b000, self.prg_bank_at_b000, 0x1000, address),
                    0xC000 ..= 0xCFFF => self.read_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x1000, address),
                    0xD000 ..= 0xDFFF => self.read_banked_memory(false, self.prg_ram_at_d000, self.prg_bank_at_d000, 0x1000, address),
                    0xE000 ..= 0xEFFF => self.read_banked_memory(false, self.prg_ram_at_e000, self.prg_bank_at_e000, 0x1000, address),
                    0xF000 ..= 0xFFFF => self.read_banked_memory(false, self.prg_ram_at_f000, self.prg_bank_at_f000, 0x1000, address),
                    _ => {None}
                }
            },
        }
    }

    fn write_prg_rom_area(&mut self, address: usize, data: u8) {
        match self.prg_rom_mode {
            PrgRomBankingMode::Mode0Bank1x32k => self.write_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x8000, address, data),
            PrgRomBankingMode::Mode1Bank2x16k => {
                match address {
                    0x8000 ..= 0xBFFF => self.write_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x4000, address, data),
                    0xC000 ..= 0xFFFF => self.write_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x4000, address, data),
                    _ => {}
                }
            },
            PrgRomBankingMode::Mode2Bank1x16k2x8k => {
                match address {
                    0x8000 ..= 0xBFFF => self.write_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x4000, address, data),
                    0xC000 ..= 0xDFFF => self.write_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x2000, address, data),
                    0xE000 ..= 0xFFFF => self.write_banked_memory(false, self.prg_ram_at_e000, self.prg_bank_at_e000, 0x2000, address, data),
                    _ => {}
                }
            },
            PrgRomBankingMode::Mode3Bank4x8k => {
                match address {
                    0x8000 ..= 0x9FFF => self.write_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x2000, address, data),
                    0xA000 ..= 0xBFFF => self.write_banked_memory(false, self.prg_ram_at_a000, self.prg_bank_at_a000, 0x2000, address, data),
                    0xC000 ..= 0xDFFF => self.write_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x2000, address, data),
                    0xE000 ..= 0xFFFF => self.write_banked_memory(false, self.prg_ram_at_e000, self.prg_bank_at_e000, 0x2000, address, data),
                    _ => {}
                }
            },
            PrgRomBankingMode::Mode4Bank8x4k => {
                match address {
                    0x8000 ..= 0x8FFF => self.write_banked_memory(false, self.prg_ram_at_8000, self.prg_bank_at_8000, 0x1000, address, data),
                    0x9000 ..= 0x9FFF => self.write_banked_memory(false, self.prg_ram_at_9000, self.prg_bank_at_9000, 0x1000, address, data),
                    0xA000 ..= 0xAFFF => self.write_banked_memory(false, self.prg_ram_at_a000, self.prg_bank_at_a000, 0x1000, address, data),
                    0xB000 ..= 0xBFFF => self.write_banked_memory(false, self.prg_ram_at_b000, self.prg_bank_at_b000, 0x1000, address, data),
                    0xC000 ..= 0xCFFF => self.write_banked_memory(false, self.prg_ram_at_c000, self.prg_bank_at_c000, 0x1000, address, data),
                    0xD000 ..= 0xDFFF => self.write_banked_memory(false, self.prg_ram_at_d000, self.prg_bank_at_d000, 0x1000, address, data),
                    0xE000 ..= 0xEFFF => self.write_banked_memory(false, self.prg_ram_at_e000, self.prg_bank_at_e000, 0x1000, address, data),
                    0xF000 ..= 0xFFFF => self.write_banked_memory(false, self.prg_ram_at_f000, self.prg_bank_at_f000, 0x1000, address, data),
                    _ => {}
                }
            },
        }
    }

    // CHR variant of that helper for regularly banked memory (ignoring extended bg/obj)
    fn read_banked_chr(&self, bank_number: usize, blocksize: usize, address: usize) -> Option<u8> {
        match self.chr_chip {
            ChrChipSelect::ChrRom => self.chr_rom.banked_read(blocksize, bank_number, address),
            ChrChipSelect::ChrRam => self.chr_ram.banked_read(blocksize, bank_number, address),
            // when using FPGA mode, banking settings are ignored, 4k mode is forced, and the
            // first 4k is mirrored to both banks
            ChrChipSelect::FpgaRam => self.fpga_ram.banked_read(0x1000, 0, address),
        }
    }

    fn write_banked_chr(&mut self, bank_number: usize, blocksize: usize, address: usize, data: u8) {
        match self.chr_chip {
            ChrChipSelect::ChrRom => {/* this space intentionally left blank */},
            ChrChipSelect::ChrRam => {
                //println!("CHR RAM: bank:{}, blocksize:{}, [${:04X}] = ${:02X}", bank_number, blocksize, address, data);
                self.chr_ram.banked_write(blocksize, bank_number, address, data)
            },
            // when using FPGA mode, banking settings are ignored, 4k mode is forced, and the
            // first 4k is mirrored to both banks
            ChrChipSelect::FpgaRam => self.fpga_ram.banked_write(0x1000, 0, address, data),
        }
    }

    fn read_banked_chr_area(&self, address: usize) -> Option<u8> {
        match self.chr_mode {
            ChrBankingMode::Mode0Bank1x8k => self.read_banked_chr(self.chr_banks[0], 0x2000, address),
            ChrBankingMode::Mode1Bank2x4k => {
                match address {
                    0x0000 ..= 0x0FFF => self.read_banked_chr(self.chr_banks[0], 0x1000, address),
                    0x1000 ..= 0x1FFF => self.read_banked_chr(self.chr_banks[1], 0x1000, address),
                    _ => {None}
                }
            },
            ChrBankingMode::Mode2Bank4x2k => {
                match address {
                    0x0000 ..= 0x07FF => self.read_banked_chr(self.chr_banks[0], 0x0800, address),
                    0x0800 ..= 0x0FFF => self.read_banked_chr(self.chr_banks[1], 0x0800, address),
                    0x1000 ..= 0x17FF => self.read_banked_chr(self.chr_banks[2], 0x0800, address),
                    0x1800 ..= 0x1FFF => self.read_banked_chr(self.chr_banks[3], 0x0800, address),
                    _ => {None}
                }
            },
            ChrBankingMode::Mode3Bank8x1k => {
                match address {
                    0x0000 ..= 0x03FF => self.read_banked_chr(self.chr_banks[0], 0x0400, address),
                    0x0400 ..= 0x07FF => self.read_banked_chr(self.chr_banks[1], 0x0400, address),
                    0x0800 ..= 0x0BFF => self.read_banked_chr(self.chr_banks[2], 0x0400, address),
                    0x0C00 ..= 0x0FFF => self.read_banked_chr(self.chr_banks[3], 0x0400, address),
                    0x1000 ..= 0x13FF => self.read_banked_chr(self.chr_banks[4], 0x0400, address),
                    0x1400 ..= 0x17FF => self.read_banked_chr(self.chr_banks[5], 0x0400, address),
                    0x1800 ..= 0x1BFF => self.read_banked_chr(self.chr_banks[6], 0x0400, address),
                    0x1C00 ..= 0x1FFF => self.read_banked_chr(self.chr_banks[7], 0x0400, address),
                    _ => {None}
                }
            },
            ChrBankingMode::Mode4Bank16x512b => {
                match address {
                    0x0000 ..= 0x01FF => self.read_banked_chr(self.chr_banks[0],  0x0200, address),
                    0x0200 ..= 0x03FF => self.read_banked_chr(self.chr_banks[1],  0x0200, address),
                    0x0400 ..= 0x05FF => self.read_banked_chr(self.chr_banks[2],  0x0200, address),
                    0x0600 ..= 0x07FF => self.read_banked_chr(self.chr_banks[3],  0x0200, address),
                    0x0800 ..= 0x09FF => self.read_banked_chr(self.chr_banks[4],  0x0200, address),
                    0x0A00 ..= 0x0BFF => self.read_banked_chr(self.chr_banks[5],  0x0200, address),
                    0x0C00 ..= 0x0DFF => self.read_banked_chr(self.chr_banks[6],  0x0200, address),
                    0x0E00 ..= 0x0FFF => self.read_banked_chr(self.chr_banks[7],  0x0200, address),
                    0x1000 ..= 0x11FF => self.read_banked_chr(self.chr_banks[8],  0x0200, address),
                    0x1200 ..= 0x13FF => self.read_banked_chr(self.chr_banks[9],  0x0200, address),
                    0x1400 ..= 0x15FF => self.read_banked_chr(self.chr_banks[10], 0x0200, address),
                    0x1600 ..= 0x17FF => self.read_banked_chr(self.chr_banks[11], 0x0200, address),
                    0x1800 ..= 0x19FF => self.read_banked_chr(self.chr_banks[12], 0x0200, address),
                    0x1A00 ..= 0x1BFF => self.read_banked_chr(self.chr_banks[13], 0x0200, address),
                    0x1C00 ..= 0x1DFF => self.read_banked_chr(self.chr_banks[14], 0x0200, address),
                    0x1E00 ..= 0x1FFF => self.read_banked_chr(self.chr_banks[15], 0x0200, address),
                    _ => {None}
                }
            }
        }
    }

    fn write_banked_chr_area(&mut self, address: usize, data: u8) {
        match self.chr_mode {
            ChrBankingMode::Mode0Bank1x8k => self.write_banked_chr(self.chr_banks[0], 0x2000, address, data),
            ChrBankingMode::Mode1Bank2x4k => {
                match address {
                    0x0000 ..= 0x0FFF => self.write_banked_chr(self.chr_banks[0], 0x1000, address, data),
                    0x1000 ..= 0x1FFF => self.write_banked_chr(self.chr_banks[1], 0x1000, address, data),
                    _ => {}
                }
            },
            ChrBankingMode::Mode2Bank4x2k => {
                match address {
                    0x0000 ..= 0x07FF => self.write_banked_chr(self.chr_banks[0], 0x0800, address, data),
                    0x0800 ..= 0x0FFF => self.write_banked_chr(self.chr_banks[1], 0x0800, address, data),
                    0x1000 ..= 0x17FF => self.write_banked_chr(self.chr_banks[2], 0x0800, address, data),
                    0x1800 ..= 0x1FFF => self.write_banked_chr(self.chr_banks[3], 0x0800, address, data),
                    _ => {}
                }
            },
            ChrBankingMode::Mode3Bank8x1k => {
                match address {
                    0x0000 ..= 0x03FF => self.write_banked_chr(self.chr_banks[0], 0x0400, address, data),
                    0x0400 ..= 0x07FF => self.write_banked_chr(self.chr_banks[1], 0x0400, address, data),
                    0x0800 ..= 0x0BFF => self.write_banked_chr(self.chr_banks[2], 0x0400, address, data),
                    0x0C00 ..= 0x0FFF => self.write_banked_chr(self.chr_banks[3], 0x0400, address, data),
                    0x1000 ..= 0x13FF => self.write_banked_chr(self.chr_banks[4], 0x0400, address, data),
                    0x1400 ..= 0x17FF => self.write_banked_chr(self.chr_banks[5], 0x0400, address, data),
                    0x1800 ..= 0x1BFF => self.write_banked_chr(self.chr_banks[6], 0x0400, address, data),
                    0x1C00 ..= 0x1FFF => self.write_banked_chr(self.chr_banks[7], 0x0400, address, data),
                    _ => {}
                }
            },
            ChrBankingMode::Mode4Bank16x512b => {
                match address {
                    0x0000 ..= 0x01FF => self.write_banked_chr(self.chr_banks[0],  0x0200, address, data),
                    0x0200 ..= 0x03FF => self.write_banked_chr(self.chr_banks[1],  0x0200, address, data),
                    0x0400 ..= 0x05FF => self.write_banked_chr(self.chr_banks[2],  0x0200, address, data),
                    0x0600 ..= 0x07FF => self.write_banked_chr(self.chr_banks[3],  0x0200, address, data),
                    0x0800 ..= 0x09FF => self.write_banked_chr(self.chr_banks[4],  0x0200, address, data),
                    0x0A00 ..= 0x0BFF => self.write_banked_chr(self.chr_banks[5],  0x0200, address, data),
                    0x0C00 ..= 0x0DFF => self.write_banked_chr(self.chr_banks[6],  0x0200, address, data),
                    0x0E00 ..= 0x0FFF => self.write_banked_chr(self.chr_banks[7],  0x0200, address, data),
                    0x1000 ..= 0x11FF => self.write_banked_chr(self.chr_banks[8],  0x0200, address, data),
                    0x1200 ..= 0x13FF => self.write_banked_chr(self.chr_banks[9],  0x0200, address, data),
                    0x1400 ..= 0x15FF => self.write_banked_chr(self.chr_banks[10], 0x0200, address, data),
                    0x1600 ..= 0x17FF => self.write_banked_chr(self.chr_banks[11], 0x0200, address, data),
                    0x1800 ..= 0x19FF => self.write_banked_chr(self.chr_banks[12], 0x0200, address, data),
                    0x1A00 ..= 0x1BFF => self.write_banked_chr(self.chr_banks[13], 0x0200, address, data),
                    0x1C00 ..= 0x1DFF => self.write_banked_chr(self.chr_banks[14], 0x0200, address, data),
                    0x1E00 ..= 0x1FFF => self.write_banked_chr(self.chr_banks[15], 0x0200, address, data),
                    _ => {}
                }
            }
        }
    }

    // Aaand a nametable variant, to round out the set
    fn read_banked_nametable(&self, chip_select: NametableChipSelect, bank_number: usize, address: usize) -> Option<u8> {
        match chip_select {
            NametableChipSelect::CiRam   =>    self.ciram.banked_read(0x0400, bank_number, address),
            NametableChipSelect::ChrRam  =>  self.chr_ram.banked_read(0x0400, bank_number, address),
            NametableChipSelect::FpgaRam => self.fpga_ram.banked_read(0x0400, bank_number, address),
            NametableChipSelect::ChrRom  =>  self.chr_rom.banked_read(0x0400, bank_number, address),
        }
    }

    fn write_banked_nametable(&mut self, chip_select: NametableChipSelect, bank_number: usize, address: usize, data: u8) {
        match chip_select {
            NametableChipSelect::CiRam   =>    self.ciram.banked_write(0x0400, bank_number, address, data),
            NametableChipSelect::ChrRam  =>  self.chr_ram.banked_write(0x0400, bank_number, address, data),
            NametableChipSelect::FpgaRam => self.fpga_ram.banked_write(0x0400, bank_number, address, data),
            //NametableChipSelect::ChrRom  =>  self.chr_rom.banked_write(0x0400, bank_number, address, data), // lol no
            _ => {}
        }
    }

    fn read_banked_nametable_area(&self, address: usize) -> Option<u8> {
        match address {
            0x2000 ..= 0x23FF => self.read_banked_nametable(self.nametable_chip_at_2000, self.nametable_bank_at_2000, address),
            0x2400 ..= 0x27FF => self.read_banked_nametable(self.nametable_chip_at_2400, self.nametable_bank_at_2400, address),
            0x2800 ..= 0x2BFF => self.read_banked_nametable(self.nametable_chip_at_2800, self.nametable_bank_at_2800, address),
            0x2C00 ..= 0x2FFF => self.read_banked_nametable(self.nametable_chip_at_2c00, self.nametable_bank_at_2c00, address),
            _ => {None}
        }
    }

    fn write_banked_nametable_area(&mut self, address: usize, data: u8) {
        match address {
            0x2000 ..= 0x23FF => self.write_banked_nametable(self.nametable_chip_at_2000, self.nametable_bank_at_2000, address, data),
            0x2400 ..= 0x27FF => self.write_banked_nametable(self.nametable_chip_at_2400, self.nametable_bank_at_2400, address, data),
            0x2800 ..= 0x2BFF => self.write_banked_nametable(self.nametable_chip_at_2800, self.nametable_bank_at_2800, address, data),
            0x2C00 ..= 0x2FFF => self.write_banked_nametable(self.nametable_chip_at_2c00, self.nametable_bank_at_2c00, address, data),
            _ => {}
        }
    }

    fn clock_irq(&mut self) {
        if self.cpu_irq_enable {
            if self.cpu_irq_counter == 0 {
                self.cpu_irq_pending = true;
                self.cpu_irq_counter = self.cpu_irq_latch;
            } else {
                self.cpu_irq_counter -= 1;
            }
        }
    }

    pub fn extended_tile_attributes(&self) -> u8 {
        let current_nametable = self.last_bg_tile_fetch & 0xC00;
        let nametable_address = self.last_bg_tile_fetch & 0x3FF;
        let attribute_byte = match current_nametable {
            0x000 => self.fpga_ram.banked_read(1024, self.exram_bank_2000, nametable_address as usize).unwrap_or(0),
            0x400 => self.fpga_ram.banked_read(1024, self.exram_bank_2400, nametable_address as usize).unwrap_or(0),
            0x800 => self.fpga_ram.banked_read(1024, self.exram_bank_2800, nametable_address as usize).unwrap_or(0),
            0xC00 => self.fpga_ram.banked_read(1024, self.exram_bank_2c00, nametable_address as usize).unwrap_or(0),
            _ => 0 // unreachable
        };
        return attribute_byte;
    }

    pub fn read_extended_chr(&self, address: usize) -> u8 {
        let chr_bank_size = 4096;
        let exattr_byte = self.extended_tile_attributes();
        let chr_bank = (self.chr_bank_high_bits << 6) | ((exattr_byte as usize) & 0b0011_1111);
        return self.read_banked_chr(chr_bank as usize, chr_bank_size, address).unwrap_or(0);
    }

    pub fn read_extended_attribute(&self) -> u8 {
        let exattr_byte = self.extended_tile_attributes();
        let palette_index = (exattr_byte & 0b1100_0000) >> 6;
        // Duplicate the palette four times; this is easier than working out which sub-index the PPU is going to
        // read here. We're overriding every fetch anyway.
        let combined_attribute = palette_index << 6 | palette_index << 4 | palette_index << 2 | palette_index;
        return combined_attribute as u8;
    }

    fn is_extended_attribute(&self) -> bool {
        let ppu_rendering_backgrounds = self.ppu_read_mode == PpuMode::Backgrounds;
        let reading_attribute_byte = (self.ppu_fetches_this_scanline % 4) == 0;

        let current_nametable = self.last_bg_tile_fetch & 0xC00;
        let extended_attributes_enabled = match current_nametable {
            0x000 => self.extended_attributes_2000,
            0x400 => self.extended_attributes_2400,
            0x800 => self.extended_attributes_2800,
            0xC00 => self.extended_attributes_2c00,
            _ => false // unreachable
        };

        return ppu_rendering_backgrounds & extended_attributes_enabled & reading_attribute_byte;
    }

    fn is_extended_pattern(&self) -> bool {
        let ppu_rendering_backgrounds = self.ppu_read_mode == PpuMode::Backgrounds;
        let tile_sub_cycle = self.ppu_fetches_this_scanline % 4;
        let reading_pattern_byte = (tile_sub_cycle == 1) || (tile_sub_cycle == 2);

        let current_nametable = self.last_bg_tile_fetch & 0xC00;
        let extended_patterns_enabled = match current_nametable {
            0x000 => self.extended_backgrounds_2000,
            0x400 => self.extended_backgrounds_2400,
            0x800 => self.extended_backgrounds_2800,
            0xC00 => self.extended_backgrounds_2c00,
            _ => false // unreachable
        };

        return ppu_rendering_backgrounds & extended_patterns_enabled & reading_pattern_byte;
    }

    fn detect_scanline(&mut self) {
        // Note: we are *currently* processing fetch #1, so we will not yet consider
        // it to have passed.
        self.ppu_fetches_this_scanline = 0;
        self.ppu_read_mode = PpuMode::Backgrounds;
        if self.in_frame {
            self.current_scanline += 1;
        } else {
            self.in_frame = true;
            self.current_scanline = 0;
            self.scanline_irq_pending = false;
        }
        if self.current_scanline == 241 {
            self.in_frame = false;
            self.in_hblank = false;
            self.scanline_irq_pending = false;
            self.current_scanline = 0;
            self.ppu_read_mode = PpuMode::PpuData;
        }
    }

    fn snoop_ppu_read(&mut self, address: u16) {
        self.cpu_cycles_since_last_ppu_read = 0;
        self.ppu_fetches_this_scanline += 1;
        if self.in_frame && self.ppu_fetches_this_scanline >= 127 {
            self.ppu_read_mode = PpuMode::Sprites;
            self.in_hblank = true;
        }
        if self.in_frame && self.ppu_fetches_this_scanline >= 159 {
            self.ppu_read_mode = PpuMode::Backgrounds;
            self.in_hblank = false;
        }
        if self.consecutive_nametable_count == 2 {
            self.detect_scanline();
        }
        if (self.current_scanline == self.scanline_irq_compare) && (self.ppu_fetches_this_scanline == self.scanline_irq_offset) {
            self.scanline_irq_pending = true;
            self.scanline_jitter_counter = 0;
        }
        if address == self.last_ppu_fetch && address >= 0x2000 && address <= 0x2FFF {
            self.consecutive_nametable_count += 1;
        } else {
            self.consecutive_nametable_count = 0;
        }
        if self.ppu_fetches_this_scanline % 4 == 0 {
            // The LAST byte we fetched was the nametable byte. Hold onto that address,
            // we need to keep track of it for ExRAM attributes.
            self.last_bg_tile_fetch = self.last_ppu_fetch;
        }
        self.last_ppu_fetch = address;
    }

    fn snoop_cpu_read(&mut self, address: u16) {
        if self.cpu_cycles_since_last_ppu_read < 255 {
            self.cpu_cycles_since_last_ppu_read += 1;
        }
        // If we go 3 CPU reads without any PPU access, assume rendering has stopped
        if self.cpu_cycles_since_last_ppu_read == 4 {
            self.in_frame = false;
            self.consecutive_nametable_count = 0;
            self.in_hblank = false;
            self.ppu_read_mode = PpuMode::PpuData;
        }
        // If we are reading the NMI vector, assume rendering has stopped AND clear
        // the scanline IRQ, if it is still pending
        if address == 0xFFFA || address == 0xFFFB {
            self.in_frame = false;
            self.consecutive_nametable_count = 0;
            self.in_hblank = false;
            self.scanline_irq_pending = false;
            self.current_scanline = 0;
            self.ppu_read_mode = PpuMode::PpuData;
        }
        self.scanline_jitter_counter = self.scanline_jitter_counter.wrapping_add(1);
    }
}

impl Mapper for Rainbow {
    fn print_debug_status(&self) {
        // TODO: ... do we even need this?
        println!("======= RAINBOW =======");        
        println!("====================");
    }

    fn mirroring(&self) -> Mirroring {
        // TODO: this is NROM! Fix this!
        return self.mirroring;
    }

    fn clock_cpu(&mut self) {
        self.vrc6_pulse1.clock();
        self.vrc6_pulse2.clock();
        self.vrc6_sawtooth.clock();
        self.clock_irq();
    }

    fn irq_flag(&self) -> bool {
        return (self.cpu_irq_pending) || (self.scanline_irq_enabled && self.scanline_irq_pending);
    }

    fn mix_expansion_audio(&self, nes_sample: f32) -> f32 {
        if self.vrc6_exp6 || self.vrc6_exp9 {
            let pulse_1_output = if !self.vrc6_pulse1.debug_disable {self.vrc6_pulse1.output() as f32} else {0.0};
            let pulse_2_output = if !self.vrc6_pulse2.debug_disable {self.vrc6_pulse2.output() as f32} else {0.0};
            let sawtooth_output = if !self.vrc6_sawtooth.debug_disable {self.vrc6_sawtooth.output() as f32} else {0.0};
            let vrc6_combined_sample = (pulse_1_output + pulse_2_output + sawtooth_output) / 61.0;

            let nes_pulse_full_volume = 95.88 / ((8128.0 / 15.0) + 100.0);
            let vrc6_pulse_full_volume = 15.0 / 61.0;
            let vrc6_weight = nes_pulse_full_volume / vrc6_pulse_full_volume;        
            return nes_sample + vrc6_combined_sample * vrc6_weight;
        } else {
            return nes_sample;
        }
    }

    fn read_cpu(&mut self, address: u16) -> Option<u8> {
        self.snoop_cpu_read(address);
        let data = self.debug_read_cpu(address);
        // side effects
        match address {
            0x4151 => {
                self.scanline_irq_pending = false
            },
            _ => {}
        }
        return data;
    }
    
    fn debug_read_cpu(&self, address: u16) -> Option<u8> {
        match address {
            // ZPCM
            0x4011 => {
                let zpcm_output = if self.vrc6_zpcm {
                    let pulse_1_output = if !self.vrc6_pulse1.debug_disable {self.vrc6_pulse1.output()} else {0};
                    let pulse_2_output = if !self.vrc6_pulse2.debug_disable {self.vrc6_pulse2.output()} else {0};
                    let sawtooth_output = if !self.vrc6_sawtooth.debug_disable {self.vrc6_sawtooth.output()} else {0};
                    let combined_output = pulse_1_output + pulse_2_output + sawtooth_output;
                    let shifted_output = combined_output << 1;
                    shifted_output
                } else {
                    0x00
                };
                Some(zpcm_output)
            },

            // PRG banking modes
            0x4100 => {
                let prg_rom_mode_bits = match self.prg_rom_mode {
                    PrgRomBankingMode::Mode0Bank1x32k       => 0b000,
                    PrgRomBankingMode::Mode1Bank2x16k       => 0b001,
                    PrgRomBankingMode::Mode2Bank1x16k2x8k   => 0b010,
                    PrgRomBankingMode::Mode3Bank4x8k        => 0b011,
                    // TODO: Does hardware preserve the low 2 bits written? If so we
                    // need an alternate approach when reading
                    PrgRomBankingMode::Mode4Bank8x4k        => 0b100
                };
                let prg_ram_mode_bits = match self.prg_ram_mode {
                    PrgRamBankingMode::Mode0Bank1x8k => 0b0000_0000,
                    PrgRamBankingMode::Mode1Bank2x4k => 0b1000_0000,
                };
                Some(prg_rom_mode_bits | prg_ram_mode_bits)
            },

            // CHR modes
            0x4120 => {
                let chr_banking_bits = match self.chr_mode {
                    ChrBankingMode::Mode0Bank1x8k => 0b000,
                    ChrBankingMode::Mode1Bank2x4k => 0b001,
                    ChrBankingMode::Mode2Bank4x2k => 0b010,
                    ChrBankingMode::Mode3Bank8x1k => 0b011,
                    ChrBankingMode::Mode4Bank16x512b => 0b100
                };
                let window_split_bit     = if self.window_split     {0b0001_0000} else {0};
                let extended_sprites_bit = if self.extended_sprites {0b0010_0000} else {0};
                let chip_select_bit = match self.chr_chip {
                    ChrChipSelect::ChrRom  => 0b0000_0000,
                    ChrChipSelect::ChrRam  => 0b0100_0000,
                    ChrChipSelect::FpgaRam => 0b1000_0000,
                };
                Some(chr_banking_bits | window_split_bit | extended_sprites_bit | chip_select_bit)
            },

            0x4151 => {
                let hblank_flag = if self.in_hblank {0b1000_0000} else {0};
                let inframe_flag = if self.in_frame {0b0100_0000} else {0};
                let scanline_pending_flag = if self.scanline_irq_pending {0b0000_0001} else {0};
                Some(hblank_flag | inframe_flag | scanline_pending_flag)
            },
            0x4154 => {
                Some(self.scanline_jitter_counter)
            },

            // mapper version
            0x4160 => {
                // 7  bit  0
                // ---- ----
                // PPPV VVVV
                // |||| ||||
                // |||+-++++- Version
                // +++------- Platform
                // Platform is one of:
                // 0   PCB
                // 1   Emulator
                // 2   Web emulator
                let platform = 0b001; // emulator
                let version  = 0;     // v1.0
                Some((platform << 5) | version)
            },

            0x4161 => {
                let cpu_irq_pending_bits = if self.cpu_irq_pending {0b0100_0000} else {0};
                Some(cpu_irq_pending_bits)
            },

            0x4800 ..= 0x4FFF => self.fpga_ram.banked_read(0x800, 3, address as usize),
            0x5000 ..= 0x5FFF => self.read_fpga_area(address as usize),
            0x6000 ..= 0x7FFF => self.read_prg_ram_area(address as usize),
            0x8000 ..= 0xFFFF => self.read_prg_rom_area(address as usize),
            _ => None
        }
    }

    fn write_cpu(&mut self, address: u16, data: u8) {
        match address {
            // PRG banking modes
            0x4100 => {
                match data & 0b111 {
                    0b000 => self.prg_rom_mode = PrgRomBankingMode::Mode0Bank1x32k,
                    0b001 => self.prg_rom_mode = PrgRomBankingMode::Mode1Bank2x16k,
                    0b010 => self.prg_rom_mode = PrgRomBankingMode::Mode2Bank1x16k2x8k,
                    0b011 => self.prg_rom_mode = PrgRomBankingMode::Mode3Bank4x8k,
                        _ => self.prg_rom_mode = PrgRomBankingMode::Mode4Bank8x4k
                };
                match (data & 0b1000_0000) >> 7 {
                    0 => self.prg_ram_mode = PrgRamBankingMode::Mode0Bank1x8k,
                    1 => self.prg_ram_mode = PrgRamBankingMode::Mode1Bank2x4k,
                    _ => {/*unreachable*/}
                };
            }
            // PRG-RAM banking (upper)
            0x4106 => {
                match (data & 0b1100_0000) >> 6 {
                    0b00 ..= 0b01 => {
                        self.prg_ram_at_6000 = false;
                        self.fpga_ram_at_6000 = false;
                        self.prg_bank_at_6000 &= 0b1000_0000_1111_1111;
                        self.prg_bank_at_6000 |= ((data as usize) & 0b0111_1111) << 8
                    },
                    0b10 => {
                        self.prg_ram_at_6000 = true;
                        self.fpga_ram_at_6000 = false;
                        self.prg_bank_at_6000 &= 0b1100_0000_1111_1111;
                        self.prg_bank_at_6000 |= ((data as usize) & 0b0011_1111) << 8
                    },
                    0b11 => {
                        self.prg_ram_at_6000 = false;
                        self.fpga_ram_at_6000 = true;
                        self.prg_bank_at_6000 &= 0b1100_0000_1111_1111;
                        self.prg_bank_at_6000 |= ((data as usize) & 0b0011_1111) << 8
                    },
                    _ => {/*unreachable*/}
                }
            },
            0x4107 => {
                match (data & 0b1100_0000) >> 6 {
                    0b00 ..= 0b01 => {
                        self.prg_ram_at_7000 = false;
                        self.fpga_ram_at_7000 = false;
                        self.prg_bank_at_7000 &= 0b1000_0000_1111_1111;
                        self.prg_bank_at_7000 |= ((data as usize) & 0b0111_1111) << 8
                    },
                    0b10 => {
                        self.prg_ram_at_7000 = true;
                        self.fpga_ram_at_7000 = false;
                        self.prg_bank_at_7000 &= 0b1100_0000_1111_1111;
                        self.prg_bank_at_7000 |= ((data as usize) & 0b0011_1111) << 8
                    },
                    0b11 => {
                        self.prg_ram_at_7000 = false;
                        self.fpga_ram_at_7000 = true;
                        self.prg_bank_at_7000 &= 0b1100_0000_1111_1111;
                        self.prg_bank_at_7000 |= ((data as usize) & 0b0011_1111) << 8
                    },
                    _ => {/*unreachable*/}
                }
            },
            // PRG-ROM banking (upper)
            0x4108 => {
                self.prg_ram_at_8000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_8000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_8000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x4109 => {
                self.prg_ram_at_9000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_9000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_9000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x410A => {
                self.prg_ram_at_a000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_a000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_a000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x410B => {
                self.prg_ram_at_b000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_b000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_b000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x410C => {
                self.prg_ram_at_c000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_c000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_c000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x410D => {
                self.prg_ram_at_d000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_d000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_d000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x410E => {
                self.prg_ram_at_e000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_e000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_e000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x410F => {
                self.prg_ram_at_f000  = (data & 0b1000_0000) != 0;
                self.prg_bank_at_f000 &= 0b1000_0000_1111_1111;
                self.prg_bank_at_f000 |= ((data as usize) & 0b0111_1111) << 8
            },
            0x4115 => {
                self.fpga_bank_at_5000 = (data & 0b1) as usize;
            }
            // PRG-RAM banking (lower)
            0x4116 => {
                self.prg_bank_at_6000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_6000 |= data as usize;
            },
            0x4117 => {
                self.prg_bank_at_7000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_7000 |= data as usize;
            },
            // PRG-ROM banking (lower)
            0x4118 => {
                self.prg_bank_at_8000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_8000 |= data as usize
            },
            0x4119 => {
                self.prg_bank_at_9000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_9000 |= data as usize
            },
            0x411A => {
                self.prg_bank_at_a000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_a000 |= data as usize
            },
            0x411B => {
                self.prg_bank_at_b000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_b000 |= data as usize
            },
            0x411C => {
                self.prg_bank_at_c000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_c000 |= data as usize
            },
            0x411D => {
                self.prg_bank_at_d000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_d000 |= data as usize
            },
            0x411E => {
                self.prg_bank_at_e000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_e000 |= data as usize
            },
            0x411F => {
                self.prg_bank_at_f000 &= 0b1111_1111_0000_0000;
                self.prg_bank_at_f000 |= data as usize
            },
            0x4120 => {
                match data & 0b0000_0111 {
                    0b000 => self.chr_mode = ChrBankingMode::Mode0Bank1x8k,
                    0b001 => self.chr_mode = ChrBankingMode::Mode1Bank2x4k,
                    0b010 => self.chr_mode = ChrBankingMode::Mode2Bank4x2k,
                    0b011 => self.chr_mode = ChrBankingMode::Mode3Bank8x1k,
                    _ => self.chr_mode = ChrBankingMode::Mode4Bank16x512b,
                };
                self.window_split     = (data & 0b0001_0000) != 0;
                self.extended_sprites = (data & 0b0010_0000) != 0;
                match (data & 0b1100_0000) >> 6 {
                    0b00 => self.chr_chip = ChrChipSelect::ChrRom,
                    0b01 => self.chr_chip = ChrChipSelect::ChrRam,
                    _    => self.chr_chip = ChrChipSelect::FpgaRam
                };
                println!("CHR mode: {:?}, chip: {:?}, splitwindow: {}, ext.sprites: {}", 
                    self.chr_mode, self.chr_chip, self.window_split, self.extended_sprites);
            },

            0x4121 => {self.chr_bank_high_bits = (data & 0b0001_1111) as usize;},

            0x4126 => self.nametable_bank_at_2000 = data as usize,
            0x4127 => self.nametable_bank_at_2400 = data as usize,
            0x4128 => self.nametable_bank_at_2800 = data as usize,
            0x4129 => self.nametable_bank_at_2c00 = data as usize,

            0x412A => {
                self.extended_attributes_2000  = (data & 0b0000_0001) != 0;
                self.extended_backgrounds_2000 = (data & 0b0000_0010) != 0;
                self.exram_bank_2000 =          ((data & 0b0000_1100) >> 2) as usize;
                match (data & 0b1100_0000) >> 6 {
                    0b00 => self.nametable_chip_at_2000 = NametableChipSelect::CiRam,
                    0b01 => self.nametable_chip_at_2000 = NametableChipSelect::ChrRam,
                    0b10 => self.nametable_chip_at_2000 = NametableChipSelect::FpgaRam,
                    0b11 => self.nametable_chip_at_2000 = NametableChipSelect::ChrRom,
                    _ => {}
                };
            },
            0x412B => {
                self.extended_attributes_2400  = (data & 0b0000_0001) != 0;
                self.extended_backgrounds_2400 = (data & 0b0000_0010) != 0;
                self.exram_bank_2400 =          ((data & 0b0000_1100) >> 2) as usize;
                match (data & 0b1100_0000) >> 6 {
                    0b00 => self.nametable_chip_at_2400 = NametableChipSelect::CiRam,
                    0b01 => self.nametable_chip_at_2400 = NametableChipSelect::ChrRam,
                    0b10 => self.nametable_chip_at_2400 = NametableChipSelect::FpgaRam,
                    0b11 => self.nametable_chip_at_2400 = NametableChipSelect::ChrRom,
                    _ => {}
                };
            },
            0x412C => {
                self.extended_attributes_2800  = (data & 0b0000_0001) != 0;
                self.extended_backgrounds_2800 = (data & 0b0000_0010) != 0;
                self.exram_bank_2800 =          ((data & 0b0000_1100) >> 2) as usize;
                match (data & 0b1100_0000) >> 6 {
                    0b00 => self.nametable_chip_at_2800 = NametableChipSelect::CiRam,
                    0b01 => self.nametable_chip_at_2800 = NametableChipSelect::ChrRam,
                    0b10 => self.nametable_chip_at_2800 = NametableChipSelect::FpgaRam,
                    0b11 => self.nametable_chip_at_2800 = NametableChipSelect::ChrRom,
                    _ => {}
                };
            },
            0x412D => {
                self.extended_attributes_2c00  = (data & 0b0000_0001) != 0;
                self.extended_backgrounds_2c00 = (data & 0b0000_0010) != 0;
                self.exram_bank_2c00 =          ((data & 0b0000_1100) >> 2) as usize;
                match (data & 0b1100_0000) >> 6 {
                    0b00 => self.nametable_chip_at_2c00 = NametableChipSelect::CiRam,
                    0b01 => self.nametable_chip_at_2c00 = NametableChipSelect::ChrRam,
                    0b10 => self.nametable_chip_at_2c00 = NametableChipSelect::FpgaRam,
                    0b11 => self.nametable_chip_at_2c00 = NametableChipSelect::ChrRom,
                    _ => {}
                };
            },

            0x4130 ..= 0x413F => {
                let bank_number = (address & 0x000F) as usize;
                self.chr_banks[bank_number] &= 0b0000_0000_1111_1111;
                self.chr_banks[bank_number] |= (data as usize) << 8;
            },
            0x4140 ..= 0x414F => {
                let bank_number = (address & 0x000F) as usize;
                self.chr_banks[bank_number] &= 0b1111_1111_0000_0000;
                self.chr_banks[bank_number] |= data as usize;
            },

            0x4150 => {
                self.scanline_irq_compare = data;
            },
            0x4151 => {
                self.scanline_irq_enabled = true;
            },
            0x4152 => {
                self.scanline_irq_enabled = false;
                self.scanline_irq_pending = false;
            },
            0x4153 => {
                self.scanline_irq_offset = data;
            },
            
            0x4158 => {
                self.cpu_irq_latch &= 0b1111_1111_0000_0000;
                self.cpu_irq_latch |= data as u16;
            },
            0x4159 => {
                self.cpu_irq_latch &= 0b0000_0000_1111_1111;
                self.cpu_irq_latch |= (data as u16) << 8;
            },
            0x415A => {
                self.cpu_irq_auto_repeat = (data & 0b0000_0001) != 0;
                self.cpu_irq_enable = (data & 0b0000_0010) != 0;
                if self.cpu_irq_enable {
                    self.cpu_irq_counter = self.cpu_irq_latch;
                }
            },
            0x415B => {
                self.cpu_irq_pending = false;
                self.cpu_irq_enable = self.cpu_irq_auto_repeat;
            },

            // Audio
            0x41A0 => self.vrc6_pulse1.write_register(0, data),
            0x41A1 => self.vrc6_pulse1.write_register(1, data),
            0x41A2 => self.vrc6_pulse1.write_register(2, data),
            0x41A3 => self.vrc6_pulse2.write_register(0, data),
            0x41A4 => self.vrc6_pulse2.write_register(1, data),
            0x41A5 => self.vrc6_pulse2.write_register(2, data),
            0x41A6 => self.vrc6_sawtooth.write_register(0, data),
            0x41A7 => self.vrc6_sawtooth.write_register(1, data),
            0x41A8 => self.vrc6_sawtooth.write_register(2, data),

            0x41A9 => {
                self.vrc6_exp6 = (data & 0b0000_0001) != 0;
                self.vrc6_exp9 = (data & 0b0000_0010) != 0;
                self.vrc6_zpcm = (data & 0b0000_0100) != 0;
            }

            0x4800 ..= 0x4FFF => self.fpga_ram.banked_write(0x800, 3, address as usize, data),
            0x5000 ..= 0x5FFF => self.write_fpga_area(address as usize, data),
            0x6000 ..= 0x7FFF => self.write_prg_ram_area(address as usize, data),
            0x8000 ..= 0xFFFF => self.write_prg_rom_area(address as usize, data),

            _ => {}
        }
    }

    fn read_ppu(&mut self, address: u16) -> Option<u8> {
        self.snoop_ppu_read(address);
        return self.debug_read_ppu(address);
    }

    fn debug_read_ppu(&self, address: u16) -> Option<u8> {
        match address {
            // TODO: need to handle extended backgrounds and sprites. This is the
            // base behavior with both of those disabled:
            0x0000 ..= 0x1FFF => {
                if self.is_extended_pattern() {
                    Some(self.read_extended_chr(address as usize))
                } else {
                    self.read_banked_chr_area(address as usize)
                }
            },
            
            // TODO: window splits, extended attributes, other fancy features
            0x2000 ..= 0x2FFF => {
                if self.is_extended_attribute() {
                    Some(self.read_extended_attribute())
                } else {
                    self.read_banked_nametable_area(address as usize)
                }
            },
            _ => return None
        }
    }

    fn write_ppu(&mut self, address: u16, data: u8) {
        match address {
            // TODO: investigate whether this goes through extended modes while rendering is
            // enabled. If it does, we should try to emulate the corrupted target address. We
            // might instead need to suppress writes during rendering.
            0x0000 ..= 0x1FFF => self.write_banked_chr_area(address as usize, data),

            // TODO: do any fancy features affect NT writes? what happens if writes occur during
            // rendering?
            0x2000 ..= 0x2FFF => self.write_banked_nametable_area(address as usize, data),
            _ => {}
        }
    }

    fn channels(&self) ->  Vec<& dyn AudioChannelState> {
        let mut channels: Vec<& dyn AudioChannelState> = Vec::new();
        channels.push(&self.vrc6_pulse1);
        channels.push(&self.vrc6_pulse2);
        channels.push(&self.vrc6_sawtooth);
        return channels;
    }

    fn channels_mut(&mut self) ->  Vec<&mut dyn AudioChannelState> {
        let mut channels: Vec<&mut dyn AudioChannelState> = Vec::new();
        channels.push(&mut self.vrc6_pulse1);
        channels.push(&mut self.vrc6_pulse2);
        channels.push(&mut self.vrc6_sawtooth);
        return channels;
    }

    fn record_expansion_audio_output(&mut self, _nes_sample: f32) {
        self.vrc6_pulse1.record_current_output();
        self.vrc6_pulse2.record_current_output();
        self.vrc6_sawtooth.record_current_output();
    }
}

// Provided courtesy of Broke Studio. The raster font contained within is assumed
// to be free of copyright restrictions.
const BOOTROM_FPGA: [u8; 4096] = [
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x81,0xA5,0x81,0xBD,0x99,0x81,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0xFF,0xDB,0xFF,0xC3,0xE7,0xFF,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x6C,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x38,0x7C,0x38,0xFE,0xFE,0xD6,0x10,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x03,0x0F,0x1C,0x30,0x30,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0xF0,0x3A,0x1E,0x0E,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1C,0x1C,0x1C,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x44,0xC6,0xC6,0xFE,0x7C,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0D,0x0D,0x00,0x0F,0xDF,0xD8,0x1B,0xDB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xB0,0xB0,0x00,0xF0,0xFB,0x1B,0xD8,0xDB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0F,0x1F,0x38,0x75,0x65,0x65,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFE,0xFE,0x06,0x56,0x56,0x56,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7F,0x63,0x7F,0x63,0x63,0x67,0xE6,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x99,0x5A,0x3C,0xE7,0xE7,0x3C,0x5A,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0xE0,0xF8,0xFE,0xF8,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x0E,0x3E,0xFE,0x3E,0x0E,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x3C,0x7E,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7F,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0xC3,0x78,0xCC,0xCC,0x78,0x8C,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x60,0x30,0x30,0x1C,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0C,0x0C,0x38,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x38,0x38,0x38,0x38,0x38,0x28,0x38,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xDB,0x1B,0xD8,0xDF,0x0F,0x00,0x0D,0x0D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xDB,0xD8,0x1B,0xFB,0xF0,0x00,0xB0,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x60,0x60,0x60,0x60,0x7F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x06,0x06,0x06,0x06,0x06,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xFF,0xFF,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x7C,0xC0,0x78,0x0C,0xF8,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x60,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x70,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0xDC,0xFC,0xEC,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0xF0,0x30,0x30,0x30,0x30,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0x0C,0x38,0x60,0xCC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0x0C,0x38,0x0C,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0xC0,0xF8,0x0C,0x0C,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x38,0x60,0xC0,0xF8,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0xCC,0x0C,0x18,0x30,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0xCC,0x78,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0xCC,0x7C,0x0C,0x18,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x30,0x30,0x00,0x70,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0x0C,0x18,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x78,0xCC,0xCC,0xFC,0xCC,0xCC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0x6C,0x66,0x66,0x66,0x6C,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0xCC,0xCC,0xDC,0x78,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0x66,0x66,0x7C,0x78,0x6C,0xE6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xCC,0xE0,0x38,0x1C,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0xB4,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC6,0xC6,0x6C,0x38,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xCC,0xCC,0xCC,0x78,0x30,0x30,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFE,0xCC,0x98,0x30,0x62,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0x60,0x7C,0x66,0x66,0x66,0xBC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x78,0xCC,0xC0,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1C,0x0C,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x78,0xCC,0xFC,0xC0,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x38,0x6C,0x60,0xF0,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x00,0x70,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x00,0x78,0x18,0x18,0x18,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x70,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xEC,0xFE,0xD6,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xF8,0xCC,0xCC,0xCC,0xCC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x78,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xD8,0x6C,0x6C,0x60,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC0,0x78,0x0C,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x30,0x7C,0x30,0x30,0x34,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xCC,0xCC,0xCC,0x78,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xC6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xCC,0xCC,0xCC,0x7C,0x0C,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFC,0x98,0x30,0x64,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1C,0x30,0x30,0xE0,0x30,0x30,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0x30,0x30,0x1C,0x30,0x30,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x38,0x6C,0xC6,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x03,0x0F,0x1E,0x3E,0x3F,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0xF0,0x78,0x7C,0xFC,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0x1F,0x3F,0x78,0x60,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0xF8,0xFC,0x1E,0x06,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x70,0xF8,0x7C,0x3F,0x1F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x1C,0x3E,0x7C,0xF8,0xF0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x03,0x05,0x0E,0x1C,0x38,0x70,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x51,0x71,0x71,0x71,0x7F,0x71,0x7F,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFA,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x07,0x0F,0x1D,0x39,0x31,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x23,0x27,0x2E,0x3C,0x38,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x47,0x47,0xE7,0x00,0x00,0xE0,0x27,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x02,0x02,0x04,0x04,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x70,0x8C,0x02,0x32,0x81,0x01,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x7E,0x3E,0x3E,0x1F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x7E,0x7C,0x7C,0xF8,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x83,0x87,0x0C,0x08,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC1,0xE1,0x30,0x10,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0F,0x1F,0x3F,0x7C,0xF8,0x70,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0xF0,0xF8,0x7C,0x3E,0x1C,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x27,0x53,0xA9,0x54,0x2A,0x15,0x0A,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7F,0x71,0x7F,0x31,0x3F,0x31,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFE,0xFE,0xFE,0xFC,0xFC,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x44,0xEE,0x7C,0x38,0x7C,0xEE,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x08,0x14,0x22,0x14,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x47,0xE7,0x00,0x00,0xE0,0x47,0x27,0xE7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x05,0x0E,0x1C,0x38,0x70,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x8C,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3C,0x7C,0xFF,0xFF,0x80,0x80,0x1F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xF8,0xF8,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3C,0xFC,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x40,0x82,0x00,0x00,0xFF,0x00,0x00,0x00,
0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x30,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x60,0x70,0x78,0x3C,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x3F,0x3F,0x3F,0x3F,0x3E,0x3E,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0xE0,0xF0,0xF8,0xFC,0x7C,0x7C,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x01,0x03,0x02,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x80,0xC0,0x40,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x7C,0x79,0x7F,0x7F,0x7E,0x7E,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFC,0x3E,0x9E,0x9E,0x3E,0x7E,0x7E,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x07,0x04,0x3F,0x7F,0x00,0x35,0x35,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xF0,0x10,0xFE,0xFF,0x00,0x56,0x56,0x56,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1F,0x1F,0x3F,0x3F,0x3F,0x3F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFE,0xFE,0xFE,0xFC,0xFC,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x3F,0x30,0x3F,0x30,0x3F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0C,0xFC,0x0C,0xFC,0x0C,0xFC,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x30,0x3E,0x3E,0x3E,0x3F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0C,0x0C,0x7C,0x7C,0x7C,0xFC,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0E,0x0E,0x1E,0x1F,0x3E,0x3E,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x70,0x70,0x78,0xF8,0x7C,0x7C,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x7E,0x7F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x7E,0xFE,0xFC,0xF8,0x38,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x7E,0x7F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7E,0x7E,0xFE,0xFC,0xF8,0x38,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x35,0x35,0x35,0x35,0x35,0x35,0x3F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x56,0x56,0x56,0x56,0x56,0x56,0xFE,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x0C,0x1E,0x3E,0x38,0x70,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x07,0x08,0x10,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xE0,0xF8,0x3C,0x1E,0x0E,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFE,0xFC,0xF8,0xF1,0xE3,0xE7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x1E,0x33,0x73,0xFE,0xFC,0xF8,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1E,0x18,0x18,0x18,0x18,0x18,0x18,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x03,0x07,0x2E,0xFC,0xF8,0xFC,0x78,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x1C,0x0F,0x0F,0x1C,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,0x0F,0x1C,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xE0,0xF0,0x38,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x3F,0x3F,0x3F,0x3E,0x3E,0x3F,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0xE0,0xF0,0xF8,0x7C,0x7C,0xFC,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x20,0x20,0x10,0x08,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE7,0xE1,0xC5,0xC8,0xC0,0xE3,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0xC0,0x80,0x10,0x30,0xF0,0xF0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1C,0x3E,0x1F,0x1F,0x3F,0x72,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x38,0xF0,0xF0,0x38,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x1C,0x0F,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x38,0xF0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3E,0x3E,0x3E,0x3E,0x3E,0x3F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7C,0x7C,0x7C,0x7C,0x7C,0xFC,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x17,0x16,0x36,0x36,0x30,0x1F,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x79,0xB6,0x32,0xBA,0x32,0x78,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x82,0x84,0x84,0x88,0x88,0x80,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x11,0x9C,0x1E,0x0F,0x1F,0x5F,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC0,0xE4,0xF0,0xFC,0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x40,0x40,0x20,0x20,0x20,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x03,0x03,0x07,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x80,0xC0,0xFE,0xFE,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0F,0x18,0x30,0x67,0xCC,0x98,0x91,0x93,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0x30,0x18,0xCC,0x66,0x32,0x12,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x07,0x1F,0x3E,0x77,0x6F,0xFE,0xDC,0xD0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE0,0xF8,0x7C,0xBE,0xBE,0x17,0x07,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x70,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x04,0x0E,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0E,0x67,0xF3,0x50,0x02,0x7C,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xE7,0x06,0xF8,0x00,0x04,0x03,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x2C,0x2C,0x38,0x00,0x00,0xE0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x10,0x00,0x7F,0x9F,0x97,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x00,0xFE,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x02,0x02,0x04,0x04,0x04,0x04,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x1F,0x1F,0x1F,0x3F,0x3F,0x78,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xF8,0xF0,0xF0,0xF0,0xF8,0xF8,0x3C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x91,0x00,0x03,0x07,0x07,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x12,0x00,0x80,0xC0,0xC0,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC8,0xC4,0xE6,0x67,0x73,0x3E,0x1F,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1F,0x1F,0x07,0x86,0x8E,0x3C,0xF8,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1E,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0xC0,0xE0,0xF0,0x70,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x07,0x0F,0x0E,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];